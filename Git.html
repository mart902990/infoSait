<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Hub</title>
    <link rel="stylesheet" href="general.css">
    
</head>
<body>

     <h2>Инициализация и работа в локальном репозитории</h2>    
        
        <details>
            <summary>инициализация </summary>
            <div class="text">
                Git хранит историю в привязке к имени пользователя и email.<br>
                Чтобы задать имя пользователя необходимо выполнить следующую
                команду:                
                <code>git config --global user.name "Vasya Pupkin"</code>
                Чтобы задать email необходимо выполнить следующую команду:
                <code>git config --global user.email vasya@localhost</code>
            <br>
            Git использует по умолчанию редактор Vim (он достаточно тяжёл для
            начинающих пользователей).<br>
            Мы можем задать редактор попроще (Nano) с помощью команды:
            <code> config --global core.editor nano</code><br>
                Репозиторий создаётся в конкретном каталоге с помощью команды:<br>
                <code>git init</code> <br>
                Если команда сработала ,то вы увидите ответ:<br>
               <code>Initialized empty Git repository in Диск:/папка/.git/</code>
            В результате выполнения команды <code> git init </code> появится подкаталог <code>.git</code>
            в котором и будут храниться служебные настройки git'а и сам   репозиторий.<br>
            <br>
            </div>
            </details>
            <details>
                <summary>локальный репозиторий </summary>
                <div class="text">
            Git будет следить только за теми файлами, которые вы добавили в «список
            отслеживаемых».<br>
            Сделать это можно с помощью команды:<code>git add index.html</code>
            где index.html — это имя добавляемого файла.<br>
            <br>
            <code> git add *</code> добавит в список отслеживаемых файлов все файлы в<br>
            текущем каталоге и подкаталогах;<br>
             <code>git add *.js</code> добавит в список отслеживаемых файлов все файлы с<br>
            расширением .js в текущем каталоге и подкаталогах.<br>
            <br>
            <code>git status</code>позволяет отследить текущий статус репозитория<br><br>

            Для фиксации изменений используется команда<code>git commit</code>  (после
            этого откроется редактор для указания комментария).<br> В редакторе nano
            нужно будет нажать клавиши Ctrl + O для записи,<br>
             Ctrl + X для  выхода из редактора .<br><br>
            </div>         
                               
            
            <figure>
            <p ><img class="picture" src="images/staging area.PNG"  alt="git commit фиксирует изменения добавленые в staging area через git add ."></p>
            <figcaption>
            git commit фиксирует только те изменения, которые были добавлены в staging area через git add  
            </figcaption>
            </figure>
            
                <div class="text"> Для операции добавления в stage файлов и их фиксации <br>
             есть специальное сокращение, позволяющее сделать всё одной командой:
            <code> commit -a -m "Добавлены Google Fonts"</code>
            Флаг -a (сокращение от --all ) говорит о том, что мы добавляем в  stage все удалённые/изменённые файлы
            (но не новые, новые нужно  добавлять отдельно).<br>
            Флаг -m "Сообщение коммита" (сокращение от -- message="Сообщение коммита" ) позволяет не открывать редактор,
             а  указывать сообщение прямо в командной строке <br><br>
            Посмотреть историю коммитов можно с помощью команды <code>git log</code><br>
            Перед коммитом файла Git вычисляет контрольную сумму, которая  является идентификатором коммита.
            Посмотреть полную информацию о коммите мы можем с помощью
            команды <code> show id-коммитта </code>. ID не обязательно писать целиком,
            достаточно первых нескольких символов:
            <code>git show 4ad7e0 </code>
             </div>            
        </details>
        <details>
           <summary>откаты в локальном репозитории </summary>
            <div class="text">
            Если вы случайно добавили в stage area файл, который добавлять не
            нужно,то удалить его можно командой:
                      <code>git rm --cached stuff.txt</code> <br>
                    Если вы случайно зафиксировали коммит с ошибочным комментарием,то
                    исправить комментарий последнего коммита можно с помощью команды:
                     <code>commit --amend -m "Roboto Font"</code> 
                    где "Roboto Font" — новое сообщение коммита.<br><br>
                    Если вы залили коммит с ошибкой,то можно создать «зеркальный»
                    коммит, который отменит действие предыдущего:<code>git revert id-коммита</code>
                    где id-коммита — идентификатор коммита.
                    Идентификатор коммита можно посмотреть с помощью команды git log .<br><br>
                                        

            </div>
        </details>
        <details>
           <summary>справка  .gitignore </summary>
            <div class="text">
                     <code>git help команда</code>справка по конкретной команде git.
                      (git help add покажет справку для команды git add) .<br>                    
                     <code>git</code> краткая справка по git
                    <br><br>
                    Для того, чтобы игнорировать файлы в Git есть специальный настроечный файл, 
                    который называется  <code>.gitignore</code>  (точка в начале имени файла обязательна!).
                    Это обычный текстовый файл, где на каждой строке размещается одно правило игнорирования.
                    Обычно этот файл располагается в самом верхнем каталоге проекта и хранится в репозитории.<br> <br>  
                    Строки, начинающиеся с символа # являются комментарием и не воспринимаются как правила.
                      <code>#</code> <br> 
                    # будут игнорироваться все файлы и каталоги Thumbs.db вне зависимости от того, в каком каталоге они находятся  
                       <code>Thumbs.db  </code><br> 
                    # будет игнорироваться каталог tmp  вне зависимости от того, в каком каталоге он находится слэш в конце указывает, что это каталог
                     <code>tmp/ </code><br> 
                       # будет игнорироваться относительно файла .gitignore  чаще всего относительно всего проекта
                        <code>/tmp/ </code><br> 
                        # будут игнорироваться все файлы и каталоги с расширением .txt вне зависимости от того, в каком каталоге они находятся
                         <code>*.txt </code>     <br><br>          
            </div>
        </details>
        <h2>Удаленный репозиторий</h2>
        <details>
              <summary> СОЗДАНИЕ РЕПОЗИТОРИЯ НА GITHUB </summary> 
               <div class="text">
               1. Name — имя репозитория, вводится английскими буквами; <br>  
               2. Description — описание репозитория (опционально); <br>  
               3. Include README — автоматическое создание README.md ; <br>  
               4. Add .gitignore — добавление преднастроенного .gitignore ; <br>  
               5. Add a license — добавление информации о лицензии. <br>  
                <figure>
            <p ><img class="picture" src="images/URL репозитория.PNG"  alt=" URL репозитория"></p>
            <figcaption>
            Для дальнейших операций нам необходим URL, по которому располагается созданный нами репозиторий
            </figcaption>
            </figure>
             Команда <code> git remote</code> позволяет нам управлять удалёнными репозиториями (добавлять, удалять, просматривать).<br>  <br>  
                     Проверим, что локальный репозиторий успешно связался с удалённым:         
                     <code> git remote -v</code><br>  
                     Общепринято, что первый удалённый репозиторий называют<code>origin</code> <br>  
            </div>
</details>
<details>
           <summary> <h3> к локальному репозиторию с проектом, привязать удаленный репозиторий на GitHub</h3></summary>
            <div class="text">

                локальный репозиторий с проектом, подключить к удалённому:
               <code> git remote add origin url репозитория </code>  <br> 
               например <code> git remote add origin https://github.com/netology-git/demo.git </code><br>       
            </div>
        </details>
        <details>
           <summary> локального репозитория еще нет, надо начать новый проект, с привязкой к удаленному репозиторию на GitHub;</summary>
            <div class="text">
               <code>git clone</code>  позволяет нам склонировать удалённый репозиторий,т.е. буквально взять почти всю информацию, хранящуюся в
                 удаленом репозитории и создать копию на нашем компьютере                 
                     <code>git clone https://github.com/netology-git/demo.git</code>
                      <code>git clone url remote repository</code>
                      <br>    
                      переходим в появившуюся папку команда<code>cd demo/</code>  нужна чтобы зайти в папку скопированного репозитория                
                     После клонирования, создастся каталог demo, с нашим репозиторием (уже привязанный к удалённому).
                    <br><br>                    
                            
            </div>
        </details>
        <h2>Работа с удаленным репозиторием</h2>
        <details>
            <summary> Добавление изменений в удаленный репозитрий</summary>
            <div class="text">
            После того, как мы поработали локально, необходимо отправить наши
            изменения в удалённый репозиторий.
            Для этого используется команда  <code>git push</code> <br> 
            для первой отправки:<code>git push -u origin master</code> <br> 
             </div>
        </details>
        <details>
            <summary>README.md язык Markdown </summary>
            <div class="text">
        <code># Заголовок первого уровня
## Заголовок второго уровня<br>
### Заголовок третьего уровня<br>
#### Заголовок четвертого уровня<br>
##### Заголовок пятого уровня<br>
###### Заголовок шестого уровня</code><br>

<code>**Жирный текст**<br>
*Наклонный текст*<br>
~~Перечеркнутый текст~~</code><br>

<code> * Элемент списка<br>
* Элемент списка<br>
* Вложенный элемент списка<br>
* Вложенный элемент списка<br>
1. Элемент упорядоченного списка<br>
1. Элемент упорядоченного списка<br>
1. Вложенный элемент списка<br>
1. Вложенный элемент списка<br>
</code><br>
<code>Гиперссылки оформляются в формате [Текст ссылки](url-адрес) :<br>
[Текст ссылки](http://localhost)</code><br>
<code>
    Изображения оформляются так же, как и гиперссылки, но перед []<br>
ставится ! ,т.е. ![логотип](url-изображения) :<br>
</code><br>

    Внутри строки: код заключается в бэктики (backticks): `строка кода`<br>
— Отдельным блоком:<br>
Для подсветки синтаксиса после верхних бэктиков укажите технологию,<br>
на которой написан кусок кода. Например, в блоке выше код написан на<br>
<code>
JavaScript. Этот язык мы и указываем.
```javascript
console.log("");``

</code>
            </div>
        </details>
      <h2> branch - ветки</h2>
  <details> <summary> работа с ветками </summary>
    <div class="text">
        Посмотреть существующие ветки можно с помощью команды
        <code>git branch</code>
        <br>
        Создать новую ветку можно с помощью команды
        <code>branch имя-новой-ветки</code> 
        <br>
         Для того, чтобы переключиться на другую ветку, необходимо использовать
        команду <code> git checkout имя-ветки</code> чтобы при переключении не было проблем,
         возьмите за привычку фиксировать все файлы до переключения
        <br>
         добавить новую ветку в GitHub  :
        <code>push –u origin feature/payment (имя ветки)</code> <br> 

        При клонировании репозитория с удалённого сервера Git автоматически
        создаёт удалённую ветку origin/master и локальную master .
        Для всех остальных удалённых веток локальные ветки не создаются их
        нужно создавать с помощью команды: git branch имя-ветки локально origin/имя-ветки-удалённо .
        Например, чтобы скопировать из удалённого репозитория ветку с
        названием edit/article нужно выполнить команду: <code> git branch edit/article origin/edit/article</code>
        В результате в локальном репозитории появится ветка edit/article ,     
        связанная с веткой в удалённом репозитории.
        <br>
        <br>  
         Удалить ветку с GitHub и локально  <code>git branch -d имя-ветки</code> 
         <code>git push --delete origin feature/payment </code>  
          <br> 

    </div>
  </details>           
         <details> <summary> слияние изменений/веток merge</summary>
  <div class="text">
        1. Переключаемся на главную ветку master ;
        2. Выполняем операцию <code>git merge --no-ff feature/payment(ветка для слива)</code> ;
        3. Заливаем всё на GitHub.
        В результате слияния создаётся новый коммит, в рамках которого и
        объединяются изменения из ветки feature/payment в ветку master .

        <br>
        Для просмотра истории конкретной ветки:
        <code>git log feature/payment --graph --oneline</code> 
        <br>
         Git умеет самостоятельно «сливать» изменения, если они не приводят к
         конфликтам.
        <figure>
            <p ><img class="picture" src="images/confl.PNG"  alt=" URL репозитория"></p>
            <figcaption>
            Конфликт выглядит в редакторе вот так
            </figcaption>
            </figure>
         мы руками должны отредактировать строки 8-12, чтобы не
         осталось символов   <code><<<<< HEAD ,======, >>>> </code>
         feature/analytics приведя файл к нужному нам виду, придётся обработать все файлы, в которых 
         возникли конфликты. Посмотреть все файлы с конфликтами можно с помощью 
        <code> git status  You have unmerged paths.
         (fix conflicts and run "git commit")
         ( use "git merge --abort" to abort the merge)</code>          
        <br>

         история в виде графа  :
        <code>git log --graph --oneline</code> <br> 
        <figure>
            <p ><img class="picture" src="images/graph.PNG"  alt=" URL репозитория"></p>
            <figcaption>
            После разрешения конфликта и коммита, граф будет выглядеть
            следующим образом:
            </figcaption>
        </figure>         
        <br>
        </div>
  </details> 

        <h2> теги</h2>
       <details>
           <summary>работа с тегами</summary>
          <div class="text">
            добавим тег в  историю:
            <code>git tag –a v1.0 –m "Версия 1.0"</code>
             <br>
             Просмотреть теги можно с помощью команды
             <code>git tag  v1.0</code>
             <br>

              <code>git show</code> позволяет получить информацию о метке
              <code>git show v1.0</code>
             <br>
             Теги можно добавить и позже, указав id-коммита:
             <code>git tag –a v1.0 –m "Версия 1.0" id-коммита</code>
               <br>
             По умолчанию теги не отправляются при выполнении git push
             Это необходимо указать явно:  ы
               <code>git push --tags </code>
               <br>
            Если вы ещё не отправили тег на GitHub,то удалить его можно командой: 
                <code> git tag -d v1.0</code>
               <br>
               Если же уже отправили,то:
                <code>git push --delete origin v1.0</code>
                <code>git tag -d v1.0</code>
               <br>
          </div> 
       </details> 
          
  
</body>
</html>