<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Hub</title>
    <link rel="stylesheet" href="general.css">
    
</head>
<body>  
         <h1>GitHub</h1>
        <details>
            <summary>инициализация </summary>
            <div class="text">
                Git хранит историю в привязке к имени пользователя и email.<br>
                Чтобы задать имя пользователя необходимо выполнить следующую
                команду:                
                <code>git config --global user.name "Vasya Pupkin"</code>
                Чтобы задать email необходимо выполнить следующую команду:
                <code>git config --global user.email vasya@localhost</code>
            <br>
            Git использует по умолчанию редактор Vim (он достаточно тяжёл для
            начинающих пользователей).<br>
            Мы можем задать редактор попроще (Nano) с помощью команды:
            <code> config --global core.editor nano</code><br>
                Репозиторий создаётся в конкретном каталоге с помощью команды:<br>
                <code>git init</code> <br>
                Если команда сработала ,то вы увидите ответ:<br>
               <code>Initialized empty Git repository in Диск:/папка/.git/</code>
            В результате выполнения команды <code> git init </code> появится подкаталог <code>.git</code>
            в котором и будут храниться служебные настройки git'а и сам   репозиторий.<br>
            <br>
            </div>
            </details>
            <details>
                <summary>локальный репозиторий </summary>
                <div class="text">
            Git будет следить только за теми файлами, которые вы добавили в «список
            отслеживаемых».<br>
            Сделать это можно с помощью команды:<code>git add index.html</code>
            где index.html — это имя добавляемого файла.<br>
            <br>
            <code> git add *</code> добавит в список отслеживаемых файлов все файлы в<br>
            текущем каталоге и подкаталогах;<br>
             <code>git add *.js</code> добавит в список отслеживаемых файлов все файлы с<br>
            расширением .js в текущем каталоге и подкаталогах.<br>
            <br>
            <code>git status</code>позволяет отследить текущий статус репозитория<br><br>

            Для фиксации изменений используется команда<code>git commit</code>  (после
            этого откроется редактор для указания комментария).<br> В редакторе nano
            нужно будет нажать клавиши Ctrl + O для записи,<br>
             Ctrl + X для  выхода из редактора .<br><br>
            </div>         
                               
            
            <figure>
            <p ><img class="picture" src="images/staging area.PNG"  alt="git commit фиксирует изменения добавленые в staging area через git add ."></p>
            <figcaption>
            git commit фиксирует только те изменения, которые были добавлены в staging area через git add  
            </figcaption>
            </figure>
            
                <div class="text"> Для операции добавления в stage файлов и их фиксации <br>
             есть специальное сокращение, позволяющее сделать всё одной командой:
            <code> commit -a -m "Добавлены Google Fonts"</code>
            Флаг -a (сокращение от --all ) говорит о том, что мы добавляем в  stage все удалённые/изменённые файлы
            (но не новые, новые нужно  добавлять отдельно).<br>
            Флаг -m "Сообщение коммита" (сокращение от -- message="Сообщение коммита" ) позволяет не открывать редактор,
             а  указывать сообщение прямо в командной строке <br><br>
            Посмотреть историю коммитов можно с помощью команды <code>git log</code><br>
            Перед коммитом файла Git вычисляет контрольную сумму, которая  является идентификатором коммита.
            Посмотреть полную информацию о коммите мы можем с помощью
            команды <code> show id-коммитта </code>. ID не обязательно писать целиком,
            достаточно первых нескольких символов:
            <code>git show 4ad7e0 </code>
             </div>            
        </details>
        <details>
           <summary>откаты в локальном репозитории </summary>
            <div class="text">
            Если вы случайно добавили в stage area файл, который добавлять не
            нужно,то удалить его можно командой:
                      <code>git rm --cached stuff.txt</code> <br>
                    Если вы случайно зафиксировали коммит с ошибочным комментарием,то
                    исправить комментарий последнего коммита можно с помощью команды:
                     <code>commit --amend -m "Roboto Font"</code> 
                    где "Roboto Font" — новое сообщение коммита.<br><br>
                    Если вы залили коммит с ошибкой,то можно создать «зеркальный»
                    коммит, который отменит действие предыдущего:<code>git revert id-коммита</code>
                    где id-коммита — идентификатор коммита.
                    Идентификатор коммита можно посмотреть с помощью команды git log .<br><br>
                                        

            </div>
        </details>
        <details>
           <summary>справка  .gitignore </summary>
            <div class="text">
                     <code>git help команда</code>справка по конкретной команде git.
                      (git help add покажет справку для команды git add) .<br>                    
                     <code>git</code> краткая справка по git
                    <br><br>
                    Для того, чтобы игнорировать файлы в Git есть специальный настроечный файл, 
                    который называется  <code>.gitignore</code>  (точка в начале имени файла обязательна!).
                    Это обычный текстовый файл, где на каждой строке размещается одно правило игнорирования.
                    Обычно этот файл располагается в самом верхнем каталоге проекта и хранится в репозитории.<br> <br>  
                    Строки, начинающиеся с символа # являются комментарием и не воспринимаются как правила.
                      <code>#</code> <br> 
                    # будут игнорироваться все файлы и каталоги Thumbs.db вне зависимости от того, в каком каталоге они находятся  
                       <code>Thumbs.db  </code><br> 
                    # будет игнорироваться каталог tmp  вне зависимости от того, в каком каталоге он находится слэш в конце указывает, что это каталог
                     <code>tmp/ </code><br> 
                       # будет игнорироваться относительно файла .gitignore  чаще всего относительно всего проекта
                        <code>/tmp/ </code><br> 
                        # будут игнорироваться все файлы и каталоги с расширением .txt вне зависимости от того, в каком каталоге они находятся
                         <code>*.txt </code>     <br><br>          
            </div>
        </details>
        
        <details>
              <summary> создание репозитория GitHub </summary> 
               <div class="text">
               1. Name — имя репозитория, вводится английскими буквами; <br>  
               2. Description — описание репозитория (опционально); <br>  
               3. Include README — автоматическое создание README.md ; <br>  
               4. Add .gitignore — добавление преднастроенного .gitignore ; <br>  
               5. Add a license — добавление информации о лицензии. <br>  
                <figure>
            <p ><img class="picture" src="images/URL репозитория.PNG"  alt=" URL репозитория"></p>
            <figcaption>
            Для дальнейших операций нам необходим URL, по которому располагается созданный нами репозиторий
            </figcaption>
            </figure>
             Команда <code> git remote</code> позволяет нам управлять удалёнными репозиториями (добавлять, удалять, просматривать).<br>  <br>  
                     Проверим, что локальный репозиторий успешно связался с удалённым:         
                     <code> git remote -v</code><br>  
                     Общепринято, что первый удалённый репозиторий называют<code>origin</code> <br>  
            </div>
</details>
<details>
           <summary>  к локальному репозиторию с проектом, привязать удаленный репозиторий на GitHub</summary>
            <div class="text">

                локальный репозиторий с проектом, подключить к удалённому:
               <code> git remote add origin url репозитория </code>  <br> 
               например <code> git remote add origin https://github.com/netology-git/demo.git </code><br>       
            </div>
        </details>
        <details>
           <summary> локального репозитория еще нет, надо начать новый проект, с привязкой к удаленному репозиторию на GitHub;</summary>
            <div class="text">
               <code>git clone</code>  позволяет нам склонировать удалённый репозиторий,т.е. буквально взять почти всю информацию, хранящуюся в
                 удаленом репозитории и создать копию на нашем компьютере                 
                     <code>git clone https://github.com/netology-git/demo.git</code>
                      <code>git clone url remote repository</code>
                      <br>    
                      переходим в появившуюся папку команда<code>cd demo/</code>  нужна чтобы зайти в папку скопированного репозитория                
                     После клонирования, создастся каталог demo, с нашим репозиторием (уже привязанный к удалённому).
                    <br><br>                    
                            
            </div>
        </details>
        
        <details>
            <summary> Добавление изменений в удаленный репозитрий</summary>
            <div class="text">
            После того, как мы поработали локально, необходимо отправить наши
            изменения в удалённый репозиторий.
            Для этого используется команда  <code>git push</code> <br> 
            для первой отправки:<code>git push -u origin master</code> <br> 
             </div>
        </details>
        <details>
            <summary>README.md язык Markdown </summary>
            <div class="text">
        <code># Заголовок первого уровня
## Заголовок второго уровня<br>
### Заголовок третьего уровня<br>
#### Заголовок четвертого уровня<br>
##### Заголовок пятого уровня<br>
###### Заголовок шестого уровня</code><br>

<code>**Жирный текст**<br>
*Наклонный текст*<br>
~~Перечеркнутый текст~~</code><br>

<code> * Элемент списка<br>
* Элемент списка<br>
* Вложенный элемент списка<br>
* Вложенный элемент списка<br>
1. Элемент упорядоченного списка<br>
1. Элемент упорядоченного списка<br>
1. Вложенный элемент списка<br>
1. Вложенный элемент списка<br>
</code><br>
<code>Гиперссылки оформляются в формате [Текст ссылки](url-адрес) :<br>
[Текст ссылки](http://localhost)</code><br>
<code>
    Изображения оформляются так же, как и гиперссылки, но перед []<br>
ставится ! ,т.е. ![логотип](url-изображения) :<br>
</code><br>

    Внутри строки: код заключается в бэктики (backticks): `строка кода`<br>
— Отдельным блоком:<br>
Для подсветки синтаксиса после верхних бэктиков укажите технологию,<br>
на которой написан кусок кода. Например, в блоке выше код написан на<br>
<code>
JavaScript. Этот язык мы и указываем.
```javascript
console.log("");``

</code>
            </div>
        </details>
      
  <details> <summary> работа с  branch - ветками </summary>
    <div class="text">
        Посмотреть существующие ветки можно с помощью команды
        <code>git branch</code>
        <br>
        Создать новую ветку можно с помощью команды
        <code>branch имя-новой-ветки</code> 
        <br>
         Для того, чтобы переключиться на другую ветку, необходимо использовать
        команду <code> git checkout имя-ветки</code> чтобы при переключении не было проблем,
         возьмите за привычку фиксировать все файлы до переключения
        <br>
         добавить новую ветку в GitHub  :
        <code>push –u origin feature/payment (имя ветки)</code> <br> 

        При клонировании репозитория с удалённого сервера Git автоматически
        создаёт удалённую ветку origin/master и локальную master .
        Для всех остальных удалённых веток локальные ветки не создаются их
        нужно создавать с помощью команды: git branch имя-ветки локально origin/имя-ветки-удалённо .
        Например, чтобы скопировать из удалённого репозитория ветку с
        названием edit/article нужно выполнить команду: <code> git branch edit/article origin/edit/article</code>
        В результате в локальном репозитории появится ветка edit/article ,     
        связанная с веткой в удалённом репозитории.
        <br>
        <br>  
         Удалить ветку с GitHub и локально  <code>git branch -d имя-ветки</code> 
         <code>git push --delete origin feature/payment </code>  
          <br> 

    </div>
  </details>           
         <details> <summary> слияние изменений/веток merge</summary>
  <div class="text">
        1. Переключаемся на главную ветку master ;
        2. Выполняем операцию <code>git merge --no-ff feature/payment(ветка для слива)</code> ;
        3. Заливаем всё на GitHub.
        В результате слияния создаётся новый коммит, в рамках которого и
        объединяются изменения из ветки feature/payment в ветку master .

        <br>
       
         Git умеет самостоятельно «сливать» изменения, если они не приводят к
         конфликтам.
        <figure>
            <p ><img class="picture" src="images/confl.PNG"  alt=" Конфликт  в редакторе "></p>
            <figcaption>
            Конфликт выглядит в редакторе вот так
            </figcaption>
            </figure>
         мы руками должны отредактировать строки 8-12, чтобы не
         осталось символов   <code><<<<< HEAD ,======, >>>> </code>
         feature/analytics приведя файл к нужному нам виду, придётся обработать все файлы, в которых 
         возникли конфликты. Посмотреть все файлы с конфликтами можно с помощью 
        <code> git status  You have unmerged paths.
         (fix conflicts and run "git commit")
         ( use "git merge --abort" to abort the merge)</code>          
        <br>

        
        </div>
  </details> 
        
       <details>
           <summary> теги</summary>
          <div class="text">
            добавим тег в  историю:
            <code>git tag –a v1.0 –m "Версия 1.0"</code>
             <br>
             Просмотреть теги можно с помощью команды
             <code>git tag  v1.0</code>
             <br>

              <code>git show</code> позволяет получить информацию о метке
              <code>git show v1.0</code>
             <br>
             Теги можно добавить и позже, указав id-коммита:
             <code>git tag –a v1.0 –m "Версия 1.0" id-коммита</code>
               <br>
             По умолчанию теги не отправляются при выполнении git push
             Это необходимо указать явно:  
               <code>git push --tags </code>
               <br>
            Если вы ещё не отправили тег на GitHub,то удалить его можно командой: 
                <code> git tag -d v1.0</code>
               <br>
               Если же уже отправили,то:
                <code>git push --delete origin v1.0</code>
                <code>git tag -d v1.0</code>
               <br>
          </div> 
       </details> 
         <details>
             <summary>история</summary>
              <div class="text">
             история в виде графа  :
        <code>git log --graph --oneline</code> <br> 
        <figure>
            <p ><img class="picture" src="images/graph.PNG"  alt=" граф будет выглядеть
            следующим образом:"></p>
            <figcaption>
            После разрешения конфликта и коммита, граф будет выглядеть
            следующим образом:
            </figcaption>
        </figure>         
        <br>
         Для просмотра истории конкретной ветки:
        <code>git log feature/payment --graph --oneline</code> 
        <br>
        Смотрим историю через <code> git log</code>
         <figure>
            <p ><img class="picture" src="images/git log.PNG"  alt=" комиты последовательно"></p>
            <figcaption>
           все  комиты последовательно ,  нет кастомизированной информации
            </figcaption>
        </figure>         
        <br>
          указать конкретный путь/имя файла<code> git log -- index.html</code>
         <figure>
            <p ><img class="picture" src="images/git log --fail.html.PNG"  alt=" комиты относящиеся конкретному файлу"></p>
            <figcaption>
             комиты относящиеся конкретному файлу
            </figcaption>
        </figure>         
        <br>
          мы можем для каждого коммита посмотреть информацию, ЕСЛИ знаем его id:<code> git show ffbf1e -- index.html</code>
         <figure>
            <p ><img class="picture" src="images/git show ffbf1e -- index.html.PNG"  alt="git show ffbf1e -- index.html.PNG"></p>
            <figcaption>
             инфа по конетному коммиту видно что конетно изменилось 
            </figcaption>
        </figure>         
        <br>
         можно совместить конретику по файлу и  раширенную инфу по всем коммитам <code>  git log -p -- index.html</code>
         <figure>
            <p ><img class="picture" src="images/git log -p -- index.html.PNG"  alt="git log -p -- index.html.PNG"></p>
            <figcaption>
             инфа по конетному коммиту 
            </figcaption>
        </figure>         
        <br>
        можно выполнить поиск конкретного коммита<code>git log --grep 'Перво'</code>
         <figure>
            <p ><img class="picture" src="images/git log --grep 'Перво'.PNG"  alt="git log --grep 'Перво'.PN"></p>
            <figcaption>
             поиск по  ЧАСТИ названия коммита
            </figcaption>
        </figure>         
        <br>
          Если же мы знаем конкретную строку для поиска,то мы можем поискать
         все коммиты, связанные с добавлением/удалением этой строки:.<code> git log -S'строка' -p </code>
         <figure>
            <p ><img class="picture" src="images/git log -S'page' -p.PNG"  alt="поиск по  общей строке входящей в несколько названия коммитов"></p>
            <figcaption>
             поиск по  общей строке входящей в несколько названия коммитов
            </figcaption>
        </figure>         
        <br>
         По умолчанию git ищет по той ветке, на которой вы в данный момент
            находитесь. Флаг --all позволяет искать по всем веткам.<code>git log --all</code>
            <br> <br> 
     посмотреть авторство всех коммитов по строчно в файле<code> git blame -L 377,381 Git.html</code>
     диапазон строк задается <code>-L 377,381</code>
         <figure>
            <p ><img class="picture" src="images/git blame.PNG"  alt="  git blame автор изменений каждой строки"></p>
            <figcaption>
             git blame автор изменений каждой строки
            </figcaption>
        </figure>         
        <br>
              </div>
         </details> 
         <details> <summary>откат изменений</summary>
            <div class="text">

                Фактически, ветка представляет из себя указатель на определённый коммит в истории,
                 который Git автоматически передвигает при создании нового коммита.
                 В каждом коммите есть специальное поле, которое содержит «родительский» (или
                «родительские», если их несколько) коммиты. Таким образом, понятие
                 принадлежности коммита ветки определяется лишь тем, содержится ли он
                 в цепочке родителя, родителя родителя и т.д. коммита, на который сейчас указывает ветка.
                 В рамках Git помимо веток, которые являются указателями на коммиты,
                 есть ещё один указатель– это HEAD . Он как раз и определяет то, в какой
                 ветке мы сейчас находимся,т.к. содержит в себе ссылку на ветку (напоминаю, что ветка – это указатель на коммит).
                 Можно передвинуть указатель HEAD не на ветку, а на определённый коммит (на который не указывает ни одна ветка)
                 Состояние, когда HEAD указывает не на ветку, а на коммит (на который не указывает ни одна ветка) называется Detached HEAD. 
                 В этом состоянии можно делать коммиты, но не рекомендуется.Для такой ситуации есть два ключевых сценария:
                <br><br>
                сценарий 1 Создать на базе этого коммита новую ветку: <code>git branch имя-ветки + git checkout имя-ветки </code>
                можно обьединить эти команды  <code>git checkout –b имя-ветки</code>
                сценарий 2 . Вернуться на другую ветку (если мы хотели просто посмотреть состояние этого коммита).
                <code> git checkout master</code><br>
                Можно вернуться к любому моменту в истории с помощью команды git checkout
                <code> git checkout id-коммита </code>
                <br>
                В Git реализован механизм, который называется <code>fast-forward</code>
                 Что он делает: если он видит при слиянии изменений, что самым простым
                сценарием является просто переместить указатель на ветку на
                определённый коммит и не делать merge commit,то он так и поступает
                В большинстве случаев это не желательное поведение, поэтому мы
                отключаем этот механизм с помощью флага <code>--no-ff</code>  <br>  

                git reset Позволяет нам передвигать указатель,тем самым эмулируя «отмену»
                коммитов (сами коммиты по факту не отменяются, мы просто перемещаем указатель).
                На самом деле отменить коммиты нельзя, можно лишь сделать новые <code>git reset</code>  <br>
                – передвигаем указатель на определённый коммит, не сохраняя никаких изменений; 
                <code> reset --hard id-коммита</code> 
               
                передвигаем указатель на определённый коммит, при этом предыдущие изменения сохраняются в рабочем каталоге и index'е;
                «Cледующие» коммиты по истории хоть и потерялись, но все изменения лежат в stage area , а также сохранились наши 
                изменения в рабочем каталоге.
                <code> reset --soft id-коммита</code>  <br>
                --mixed (по умолчанию, можно не указывать) – передвигаем указатель на определённый коммит, при этом
                  предыдущие изменения сохраняются в рабочем каталоге, но не в index'е. «Cледующие» коммиты по истории хоть
                   и потерялись, но все изменения из коммитов и из рабочего каталога лежат в рабочем каталоге (но не в stage area ).
                <code> reset --mixed id-коммита</code>  <br>
                Вместо того, чтобы каждый раз указывать id-коммита, мы можем воспользоваться специальным синтаксисом:
                <code>git reset режим HEAD~число</code>
                Это будет значить, что мы хотим отойти от HEAD на n-шагов, указанных числом после ~ .<br><br>

            </div>  
         </details>
         <details>
             <summary> удалённые ветки</summary>
             <div class="text">
                Удалённые ветки - это «специальные локальные ветки», задача которых
                указывать на состояние ветки в удалённом репозитории на момент
                последней синхронизации между вашим локальным репозиторием и удалённым.
               <figure style=" width: 680px;">
                    <p ><img class="picture" src="images/удаленные ветки.PNG"  alt="удаленные ветки" style=" width: 500px;" ></p>
                 <figcaption>
                  .
                </figcaption>
                 </figure>         
                <br>
             </div>
             
         </details>

          <details>
             <summary></summary>
             <div class="text">

             </div>
             
         </details>
         
</body>
</html>